import fs from "node:fs";
import path from "node:path";
import readline from "node:readline";
import { stringify } from "yaml";
import {
  CANONICAL_COLUMNS,
  INIT_DEFAULT_BOARD_PATH,
  INIT_DEFAULT_TASKS_DIR,
} from "../constants.js";
import { buildStatecraftRuleBody } from "./rule-content.js";

export interface InitAnswers {
  boardName: string;
  columns: Array<{ name: string; limit?: number }>;
  boardPath: string;
  tasksDir: string;
}

/** Raw answers collected from prompts (before parsing WIP or booleans). */
interface CollectedInitAnswers {
  boardName: string;
  boardPath: string;
  tasksDir: string;
  wipStr: string;
  generateCursorRule: boolean;
  generateClaudeRule: boolean;
  generateCodexAgents: boolean;
}

function question(rl: readline.Interface, prompt: string, defaultValue?: string): Promise<string> {
  const suffix = defaultValue !== undefined ? ` (default: ${defaultValue})` : "";
  return new Promise((resolve) => {
    rl.question(`${prompt}${suffix}: `, (answer) => {
      const trimmed = answer.trim();
      resolve(trimmed !== "" ? trimmed : (defaultValue ?? ""));
    });
  });
}

async function getAnswer(
  rl: readline.Interface | null,
  answers: string[] | undefined,
  index: { current: number },
  prompt: string,
  defaultValue?: string
): Promise<string> {
  if (answers !== undefined) {
    const raw = answers[index.current++] ?? "";
    const trimmed = raw.trim();
    return trimmed !== "" ? trimmed : (defaultValue ?? "");
  }
  return question(rl!, prompt, defaultValue);
}

function parseWipLimit(wipStr: string): number | undefined {
  if (wipStr === "") return undefined;
  const n = parseInt(wipStr, 10);
  return Number.isInteger(n) && n >= 1 ? n : undefined;
}

/** Collect all init prompts into a structured object. */
async function collectInitAnswers(
  rl: readline.Interface | null,
  answers: string[] | undefined,
  index: { current: number }
): Promise<CollectedInitAnswers> {
  const boardName = await getAnswer(rl, answers, index, "Board name");
  const boardPath = await getAnswer(rl, answers, index, "Path for board file", INIT_DEFAULT_BOARD_PATH);
  const tasksDir = await getAnswer(
    rl,
    answers,
    index,
    "Directory for task .md files (relative to board)",
    INIT_DEFAULT_TASKS_DIR
  );
  const wipStr = await getAnswer(
    rl,
    answers,
    index,
    "WIP limit for In Progress (optional, press Enter to skip)",
    ""
  );
  const genCursor = await getAnswer(rl, answers, index, "Generate Cursor rule? (Y/n)", "Y");
  const genClaude = await getAnswer(rl, answers, index, "Generate Claude Code rule? (y/n)", "n");
  const genCodex = await getAnswer(rl, answers, index, "Generate Codex instructions (AGENTS.md)? (y/n)", "n");

  return {
    boardName,
    boardPath,
    tasksDir,
    wipStr,
    generateCursorRule: /^y(es)?$/i.test(genCursor.trim()),
    generateClaudeRule: /^y(es)?$/i.test(genClaude.trim()),
    generateCodexAgents: /^y(es)?$/i.test(genCodex.trim()),
  };
}

/** Build the board object (name, columns, empty tasks) from collected answers. */
function buildBoardFromAnswers(
  boardName: string,
  tasksDir: string,
  wipStr: string
): { board: string; columns: Array<string | { name: string; limit: number }>; tasks: Record<string, never> } {
  const inProgressLimit = parseWipLimit(wipStr);
  const columns: Array<string | { name: string; limit: number }> = [
    CANONICAL_COLUMNS[0],
    CANONICAL_COLUMNS[1],
    inProgressLimit != null ? { name: CANONICAL_COLUMNS[2], limit: inProgressLimit } : CANONICAL_COLUMNS[2],
    CANONICAL_COLUMNS[3],
  ];
  return {
    board: boardName,
    columns,
    tasks: {},
  };
}

/** Ensure parent directory exists and write file. */
function ensureDirAndWrite(filePath: string, content: string): void {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(filePath, content, "utf-8");
}

/** Write board YAML to cwd-relative path. */
function writeBoardFile(
  cwd: string,
  boardPath: string,
  board: { board: string; columns: unknown[]; tasks: object }
): void {
  const absolutePath = path.resolve(cwd, boardPath);
  const yamlContent = stringify(board, { lineWidth: 0 });
  ensureDirAndWrite(absolutePath, yamlContent);
}

/** Write a rule file and optionally log. */
function writeRuleFile(
  filePath: string,
  content: string,
  log: (msg: string) => void
): void {
  ensureDirAndWrite(filePath, content);
  log(filePath);
}

const CODECX_MARKER = "## Statecraft (generated by statecraft init)";

function writeCursorRule(cwd: string, boardPath: string, specDir: string, log: (msg: string) => void): void {
  const cursorRulesDir = path.resolve(cwd, ".cursor", "rules");
  const cursorRulePath = path.join(cursorRulesDir, "statecraft.mdc");
  const content = buildCursorRuleContent(boardPath, specDir);
  writeRuleFile(cursorRulePath, content, (p) => log(`Wrote Cursor rule to ${p}`));
}

function writeClaudeRule(cwd: string, boardPath: string, specDir: string, log: (msg: string) => void): void {
  const claudeRulesDir = path.resolve(cwd, ".claude", "rules");
  const claudeRulePath = path.join(claudeRulesDir, "statecraft.md");
  const content = buildClaudeRuleContent(boardPath, specDir);
  writeRuleFile(claudeRulePath, content, (p) => log(`Wrote Claude Code rule to ${p}`));
}

function writeCodexRule(cwd: string, boardPath: string, specDir: string, log: (msg: string) => void): void {
  const codexAgentsPath = path.resolve(cwd, "AGENTS.md");
  const codexContent = buildCodexAgentsContent(boardPath, specDir);
  if (fs.existsSync(codexAgentsPath)) {
    const existing = fs.readFileSync(codexAgentsPath, "utf-8");
    if (existing.includes(CODECX_MARKER)) {
      log("AGENTS.md already contains Statecraft section; skipped.");
      return;
    }
    fs.writeFileSync(codexAgentsPath, existing.trimEnd() + "\n\n" + codexContent + "\n", "utf-8");
    log(`Appended Statecraft section to ${codexAgentsPath}`);
  } else {
    fs.writeFileSync(codexAgentsPath, codexContent + "\n", "utf-8");
    log(`Wrote Codex instructions to ${codexAgentsPath}`);
  }
}

// --- Public rule content builders (used by init and by tests) ---

export function buildCursorRuleContent(boardPath: string, tasksDir: string): string {
  return `---
description: Statecraft board and task workflow; when to update the board and how to create tasks
alwaysApply: false
---
${buildStatecraftRuleBody(boardPath, tasksDir)}`;
}

/** Claude Code: modular rule in .claude/rules/ (markdown, no frontmatter). */
export function buildClaudeRuleContent(boardPath: string, tasksDir: string): string {
  return buildStatecraftRuleBody(boardPath, tasksDir);
}

/** Codex: section for AGENTS.md at project root. */
export function buildCodexAgentsContent(boardPath: string, tasksDir: string): string {
  return `## Statecraft (generated by statecraft init)

${buildStatecraftRuleBody(boardPath, tasksDir)}`;
}

// --- runInit ---

export interface RunInitOptions {
  /** For tests: pre-filled answers (board name, board path, tasks dir, WIP, Cursor y/n, Claude y/n, Codex y/n). */
  answers?: string[];
  /** For tests: working directory for writing board and rule files (default: process.cwd()). */
  cwd?: string;
}

export async function runInit(options?: RunInitOptions): Promise<void> {
  const answers = options?.answers;
  const cwd = options?.cwd ?? process.cwd();
  const answerIndex = { current: 0 };
  const rl = answers === undefined ? readline.createInterface({ input: process.stdin, output: process.stdout }) : null;
  const log = (msg: string) => {
    if (rl) process.stdout.write(msg + "\n");
  };

  try {
    if (rl) {
      process.stdout.write("\nStatecraft init â€” create your board and connect it to your workflow.\n\n");
    }

    const collected = await collectInitAnswers(rl, answers, answerIndex);
    if (!collected.boardName) {
      process.stderr.write("Board name is required.\n");
      process.exitCode = 1;
      return;
    }

    rl?.close();

    const board = buildBoardFromAnswers(collected.boardName, collected.tasksDir, collected.wipStr);
    writeBoardFile(cwd, collected.boardPath, board);

    const absolutePath = path.resolve(cwd, collected.boardPath);
    log(`\nCreated board at ${absolutePath}`);
    log(`Task spec files: ${path.join(path.dirname(collected.boardPath), collected.tasksDir)}/<task-id>.md`);

    const specDir = path.join(path.dirname(collected.boardPath), collected.tasksDir);

    if (collected.generateCursorRule) writeCursorRule(cwd, collected.boardPath, specDir, log);
    if (collected.generateClaudeRule) writeClaudeRule(cwd, collected.boardPath, specDir, log);
    if (collected.generateCodexAgents) writeCodexRule(cwd, collected.boardPath, specDir, log);

    log("\nRun `statecraft validate " + collected.boardPath + "` to validate, or `statecraft render " + collected.boardPath + "` to view.");
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    process.stderr.write(message + "\n");
    process.exitCode = 1;
  } finally {
    rl?.close();
  }
}
