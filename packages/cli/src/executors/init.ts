import fs from "node:fs";
import path from "node:path";
import readline from "node:readline";
import { stringify } from "yaml";

const DEFAULT_BOARD_PATH = "docs-private/board.yaml";
const DEFAULT_TASKS_DIR = "tasks";

export interface InitAnswers {
  boardName: string;
  columns: Array<{ name: string; limit?: number }>;
  boardPath: string;
  tasksDir: string;
}

function question(rl: readline.Interface, prompt: string, defaultValue?: string): Promise<string> {
  const suffix = defaultValue !== undefined ? ` (default: ${defaultValue})` : "";
  return new Promise((resolve) => {
    rl.question(`${prompt}${suffix}: `, (answer) => {
      const trimmed = answer.trim();
      resolve(trimmed !== "" ? trimmed : (defaultValue ?? ""));
    });
  });
}

function questionWithDefault(rl: readline.Interface, prompt: string, defaultValue: string): Promise<string> {
  return question(rl, prompt, defaultValue);
}

const CANONICAL_COLUMNS = ["Backlog", "Ready", "In Progress", "Done"] as const;

const STATECRAFT_RULE_BODY = (
  boardPath: string,
  tasksDir: string
) => `# Statecraft

This project uses Statecraft for the task board.

- **Board file:** \`${boardPath}\`
- **Task spec files:** \`${tasksDir}/<task-id>.md\` (relative to board directory)
- **Columns (canonical):** Backlog → Ready → In Progress → Done.

## Commands

- Get board format spec: \`statecraft spec\`
- Validate board: \`statecraft validate ${boardPath}\`
- View board in browser: \`statecraft render ${boardPath}\`

## Task lifecycle (edit board and task files directly)

- **Prepare for work:** When the task has a clear definition and dependencies are satisfied, set \`status\` to **Ready**.
- **Start work:** Set the task's \`status\` to **In Progress**. Optionally open/read the task's \`spec\` file.
- **Finish work:** Set the task's \`status\` to **Done** only when the task's acceptance criteria (in its spec file) are satisfied.
- **Create task:** Add an entry under \`tasks\` with \`status: Backlog\` (id, title, optional description, spec, owner, priority, depends_on). If needed, create \`${tasksDir}/<task-id>.md\` with description and DoD.

## AI guidelines for creating tickets

- **Task naming:** kebab-case, verb or noun phrase (e.g. \`fix-auth-timeout\`).
- **Description:** One line summary; optional markdown for context.
- **Definition of Done:** Acceptance criteria in task spec; all checked before moving to Done.
- **Task fields (from spec):** \`title\` (required), \`status\` (required), optional \`description\`, \`spec\` (path to .md), \`owner\`, \`priority\`, \`depends_on\`.
- **Spec file:** Path relative to board directory, e.g. \`${tasksDir}/<task-id>.md\`.
`;

export function buildCursorRuleContent(boardPath: string, tasksDir: string): string {
  return `---
description: Statecraft board and task workflow; when to update the board and how to create tasks
alwaysApply: false
---
${STATECRAFT_RULE_BODY(boardPath, tasksDir)}`;
}

/** Claude Code: modular rule in .claude/rules/ (markdown, no frontmatter). */
export function buildClaudeRuleContent(boardPath: string, tasksDir: string): string {
  return STATECRAFT_RULE_BODY(boardPath, tasksDir);
}

/** Codex: section for AGENTS.md at project root. */
export function buildCodexAgentsContent(boardPath: string, tasksDir: string): string {
  return `## Statecraft (generated by statecraft init)

${STATECRAFT_RULE_BODY(boardPath, tasksDir)}`;
}

export interface RunInitOptions {
  /** For tests: pre-filled answers (board name, board path, tasks dir, WIP for In Progress optional, Cursor y/n, Claude y/n, Codex y/n). Order must match init prompts. */
  answers?: string[];
  /** For tests: working directory for writing board and rule files (default: process.cwd()). */
  cwd?: string;
}

async function getAnswer(
  rl: readline.Interface | null,
  answers: string[] | undefined,
  index: { current: number },
  prompt: string,
  defaultValue?: string
): Promise<string> {
  if (answers !== undefined) {
    const raw = answers[index.current++] ?? "";
    const trimmed = raw.trim();
    return trimmed !== "" ? trimmed : (defaultValue ?? "");
  }
  return question(rl!, prompt, defaultValue);
}

export async function runInit(options?: RunInitOptions): Promise<void> {
  const answers = options?.answers;
  const cwd = options?.cwd ?? process.cwd();
  const answerIndex = { current: 0 };
  const rl = answers === undefined ? readline.createInterface({ input: process.stdin, output: process.stdout }) : null;

  try {
    if (rl) {
      process.stdout.write("\nStatecraft init — create your board and connect it to your workflow.\n\n");
    }

    const boardName = await getAnswer(rl, answers, answerIndex, "Board name");
    if (!boardName) {
      process.stderr.write("Board name is required.\n");
      process.exitCode = 1;
      return;
    }

    const boardPath = await getAnswer(rl, answers, answerIndex, "Path for board file", DEFAULT_BOARD_PATH);
    const tasksDir = await getAnswer(
      rl,
      answers,
      answerIndex,
      "Directory for task .md files (relative to board)",
      DEFAULT_TASKS_DIR
    );

    const wipStr = await getAnswer(
      rl,
      answers,
      answerIndex,
      "WIP limit for In Progress (optional, press Enter to skip)",
      ""
    );

    const genCursor = await getAnswer(rl, answers, answerIndex, "Generate Cursor rule? (Y/n)", "Y");
    const generateCursorRule = /^y(es)?$/i.test(genCursor.trim());

    const genClaude = await getAnswer(rl, answers, answerIndex, "Generate Claude Code rule? (y/n)", "n");
    const generateClaudeRule = /^y(es)?$/i.test(genClaude.trim());

    const genCodex = await getAnswer(rl, answers, answerIndex, "Generate Codex instructions (AGENTS.md)? (y/n)", "n");
    const generateCodexAgents = /^y(es)?$/i.test(genCodex.trim());
    let inProgressLimit: number | undefined;
    if (wipStr !== "") {
      const n = parseInt(wipStr, 10);
      if (Number.isInteger(n) && n >= 1) inProgressLimit = n;
    }

    rl?.close();

    const columns: Array<string | { name: string; limit: number }> = [
      CANONICAL_COLUMNS[0],
      CANONICAL_COLUMNS[1],
      inProgressLimit != null ? { name: CANONICAL_COLUMNS[2], limit: inProgressLimit } : CANONICAL_COLUMNS[2],
      CANONICAL_COLUMNS[3],
    ];
    const board = {
      board: boardName,
      columns,
      tasks: {},
    };

    const yamlContent = stringify(board, { lineWidth: 0 });
    const absolutePath = path.resolve(cwd, boardPath);
    const dir = path.dirname(absolutePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(absolutePath, yamlContent, "utf-8");

    if (rl) {
      process.stdout.write(`\nCreated board at ${absolutePath}\n`);
      process.stdout.write(`Task spec files: ${path.join(path.dirname(boardPath), tasksDir)}/<task-id>.md\n`);
    }

    const specDir = path.join(path.dirname(boardPath), tasksDir);

    if (generateCursorRule) {
      const cursorRulesDir = path.resolve(cwd, ".cursor", "rules");
      if (!fs.existsSync(cursorRulesDir)) {
        fs.mkdirSync(cursorRulesDir, { recursive: true });
      }
      const cursorRulePath = path.join(cursorRulesDir, "statecraft.mdc");
      fs.writeFileSync(cursorRulePath, buildCursorRuleContent(boardPath, specDir), "utf-8");
      if (rl) process.stdout.write(`Wrote Cursor rule to ${cursorRulePath}\n`);
    }

    if (generateClaudeRule) {
      const claudeRulesDir = path.resolve(cwd, ".claude", "rules");
      if (!fs.existsSync(claudeRulesDir)) {
        fs.mkdirSync(claudeRulesDir, { recursive: true });
      }
      const claudeRulePath = path.join(claudeRulesDir, "statecraft.md");
      fs.writeFileSync(claudeRulePath, buildClaudeRuleContent(boardPath, specDir), "utf-8");
      if (rl) process.stdout.write(`Wrote Claude Code rule to ${claudeRulePath}\n`);
    }

    if (generateCodexAgents) {
      const codexAgentsPath = path.resolve(cwd, "AGENTS.md");
      const codexContent = buildCodexAgentsContent(boardPath, specDir);
      const marker = "## Statecraft (generated by statecraft init)";
      if (fs.existsSync(codexAgentsPath)) {
        const existing = fs.readFileSync(codexAgentsPath, "utf-8");
        if (existing.includes(marker)) {
          if (rl) process.stdout.write(`AGENTS.md already contains Statecraft section; skipped.\n`);
        } else {
          fs.writeFileSync(codexAgentsPath, existing.trimEnd() + "\n\n" + codexContent + "\n", "utf-8");
          if (rl) process.stdout.write(`Appended Statecraft section to ${codexAgentsPath}\n`);
        }
      } else {
        fs.writeFileSync(codexAgentsPath, codexContent + "\n", "utf-8");
        if (rl) process.stdout.write(`Wrote Codex instructions to ${codexAgentsPath}\n`);
      }
    }

    if (rl) {
      process.stdout.write("\nRun `statecraft validate " + boardPath + "` to validate, or `statecraft render " + boardPath + "` to view.\n");
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    process.stderr.write(message + "\n");
    process.exitCode = 1;
  } finally {
    rl?.close();
  }
}
